-算法
所谓算法，即特定模型下，旨在解决特定问题的指令序列

-算法主要的要素
输入 	待处理的信息（问题）
输出 	经处理的信息（答案）
正确性	确实可以解决指定的问题
确定性	任一算法都可以描述为一个由基本操作组成的序列
可行行	每一基本操作都可以实现，且在常数时间内完成
又穷行	对于任何输入，经过有穷次基本操作，都可以得到输出
... ...

-例子：HailStone sequence	冰雹猜想

			 {1}					n<=1
HailStone(n){{n} U HailStone(n/2)	n偶
			 {n} U HailStone(3n+1)  n奇数
			 
-好算法
正确		符合语法，能编译，链接 能正确处理任意合法的输入
健壮		能辨别不合法的输入并能做适当处理
可读		结构化 + 准确命名 + 注释
效率		速度尽可能快；存储空间 尽可能少
		Algorithms + Data Structures = Programs			/N.Writh
		
-度量
To measure is to know
If you can not measure it,
you can not improve it.
-Lord Kelvin		

-成本
运行时间 + 所需存储空间

-特定问题 + 不同算法
不同的算法，可能更适应于不同规模的输入
不同的算法，可能更适应于不同类型的输入
同一算法，可能由于程序员的不同，编程语言的不同，经不同编译器的实现
同一算法，可能运行于不同的体系结构，操作系统
 比如cpu的速度，硬盘的速度，带宽等等
 
因此，为客观的评判，需要抽象出一个理想的平台或模型，不再依赖以上种种具体因素
从而直接而准确地描述，测量并评价算法。


----------------------------度量的尺子
-RAM模型
random access machine

寄存器顺序编号，总数没有限制
R[0], R[1],R[2],R[3]....

每一基本操作仅需常数时间
R[i] <- c
R[i] <- R[j]
.....
RAM 是一种计算工具的简化于抽象

在这些模型中，将算法的运行时间，转换成算法需要执行的基本操作次数

-渐进分析，大O记号（big -o notation）
T(n) = O(f(n)),存在c>0 当n足够大后，有T(n) < cf(n);

常系数忽略
低次项忽略

O(n) 反应了T(n)的上界
Ω(n) 反应了T(N)的下界
θ(n) 准确界定
一般从悲观的角度分析，所以大O用的较多

-常数O(1)
2 = 2013 = 2013x2013 = O(1)

-对数O(logn)
常底数无所谓
常数次幂无所谓

-多项式算法O(n)，通常认为是可以令人满意的

-指数算法O(2^n),这类算法计算成本增加极快，通常认为是不可忍受，属于难解问题。

-很多问题的指数算法往往很容易，而要设计其多项式算法却极其的不易

-问题
s包含n个正整数，ΣS = 2M;
s是否包含子集T，满足ΣT = M；
此问题不存在多项式的算法

-算数级数，于末项平方同阶
T(n) = 1+2+3+4+ ... +n = n(n+1)/2 = O(n2)

-幂方级数，比幂次高出一阶
T(n) = 1^2+ 2^2 + ..+ n^2 = n(n+1)(2n+1)/6 = O(n^3)

-几何级数，与末项同阶
Ta(n) = a^0 + a^1 +a^2 +...+ a^n = O(a^n);


-循环vs级数
双重循环 O(n^2);


-递归跟踪
检查每个递归实例
累计所需时间，其总和即算法执行时间


-动态规划
很多时候递归的效率并不能让人满意
通过递归找出算法的本质，再将其等效的转化为迭代













			 